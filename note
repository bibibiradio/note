2012-11-18
字符切换到图形 :startx
图形切换到字符：ctrl+alt+f1~6 (1--6 = tty1--tty6)
启动字符模式：vi /etc/inittab 将5改为3
。。。。       ：将3改为5
sockaddr_ll(链路层地址)：
struct sockaddr_ll
{
unsigned short sll_family; /* 总是 AF_PACKET */
unsigned short sll_protocol; /* 物理层的协议 */
int sll_ifindex; /* 接口号 */
unsigned short sll_hatype; /* 报头类型 */
unsigned char sll_pkttype; /* 分组类型 */
/*
PACKET_HOST 发送给自己的
PACKET_BROADCAST 广播的
PACKET_MULTICAST 物理层多播的
PACKET_OTHERHOST 发送给其他主机的
PACKET_OUTGOING 本机发送出去又接收到的
*/
unsigned char sll_halen; /* 地址长度 */
unsigned char sll_addr[8]; /* 物理层地址 */
};
yum -y install xxx:安装xxx
yum -y check-update:显示可升级的
yum -y update xxx:升级xxx
yum -y info xxx:查看xxx的信息
yum -y remove xxx:卸载xxx
rpm -qa xxx:查看xxx的

源码安装
tar
make
make install
make clean
卸载
make clean
make uninstall

2012-11-19
gdb xxx
set args arg1 arg2 ...
p /.. exp   /x 16进制 /d 10进制 /s 字符串 /c 字符
p 首元素@元素个数  打印数组及内存
bt 查看代码堆栈信息
f 查看代码堆顶信息
f n 查看第n层堆栈信息
b filename:line 在某文件的某行打断点
b funcname 在某函数打断点
b ... if ... 在条件成立时暂停
b filename:line threadid 在某线程的某代码打断点
delete n 删除n断点
info b 查看各断点
info locals 查看局部变量
info args 查看函数参数
info registers 查看寄存器
info handle 查看信号
info program 查看进程信息
disassemble funcname 查看汇编代码
n = next 步过
s = step 步入
finish 运行完当前函数 并打印此函数信息
u 运行步过循环
si ni 单步过机器指令
signal signo 产生signo信号
l 查看代码
handle signo keyword  keyword:stop nostop print noprint pass nopass
info threads 查看各线程
catch event  event=throw,catch,fork,vfork,exec,load,unload  在执行这些时暂停

2012-11-22
grub
mbr:主引导扇区
pbr:分区引导扇区
一般第一个磁道都是空余的，或者说第一个分区从第二个磁道开始
mbr是必须的，pbr在主分区是可选的
一般开机引导mbr,mbr引导pbr
grub写到mbr中或pbr中
grub中可以识别文件系统，可以执行grub命令
root (hdx,y) :将第x+1个块设备的第y+1个分区设置成grub根目录
kernel path param :将path中的文件作为linux内核，并将param作为内核命令参数给内核
initrd path :将path作为初始化模块给linux系统
chainloader (hdx,y) :链式加载某个分区
boot :开始引导
ls cat可用

grub4dos
写入mbr或pbr，加载grldr,grldr执行menu.lst的内容
map (hdx) (hdy) :将hdx映射到hdy,hdy可不存在，hdx可为文件(但必须连续)
map --mem (hdx) (hdy) :将hdx(可不连续)映射到hdy，且在内存中
map --hook ：前面的map命令马上生效

2012-12-23
fdisk -l :查看各种块设备的信息
df -al :查看挂载文件系统的使用情况

dd命令使用
if = input file :输入文件(可以是设备文件)
of = output file :输出文件(可以是设备文件)
ibs = input bs : 输入块的大小(bytes)
obs = output bs : 输出块的大小(bytes)
bs : 输入输出块的大小(bytes)
skip : 从输入文件跳过skip个块复制
seek : 从输出文件跳过seek个块复制
count : 复制count个块(块大小为ibs)

2013-3-7
dmesg | tail 
modinfo  ./igb.ko | grep depend   找模块的依赖，结果如下，

depends:        dca

然后再执行： 

localhost:/opt/igb/igb-4.0.17/src #  modprobe dca

localhost:/opt/igb/igb-4.0.17/src #  insmod ./igb.ko 

2013-4-25
windows下磁盘修复命令
chkdsk c: /f

2013-4-26
ipcs : 查看系统进程间通信情况
whereis : 查看某文件所在位置
ln -s a b:建立a的符号连接b,符号连接在统一性上很方便

2013-4-27
linux安装默认一般在/usr/local下
linux安装流程（祥）:
configure:检查编译连接所需要的条件，设置安装路径，根据configure创建Makefile文件。
--help :查看configure所支持的参数
--prefix=path ：设置安装目录
--with-xxx=path :设置编译所需要的库位置
--enable-xxx :开启某个功能，使编译安装的软件具有如此功能
--disable-xxx :关闭某功能，....不具有...
make :编译连接，不会在之前设置的安装路径下产生任何文件和目录，只是在源文件下产生.o .a .la文件
make clean :清楚make所产生的.o .a .la等文件
make install :configure阶段所设置的安装目录下建立目录(bin lib include等)，將之前编译连接好的.o .a .la再连接生成可执行文件,.so等最终输出文件放到安装目录中
make uninstall :依照configure所设置的安装目录进行清理

linux目录心得
/usr/local :各软件的默认安装路径
/usr/bin :公共命令的可执行文件存放位置
/usr/sbin :设置执行位或者仅root能使用的命令执行文件所在位置
/lib :系统公共库所在位置
/usr/lib :公共库所在位置
/opt :软件一般安装位置（相当于windows下的programe）
/tmp :临时文件位置
/var :运行时要改变的东西，比如锁文件，一些临时文件，邮件，logs等
/var/run :守护进程唯一性位置
/var/logs :日志

linux归档压缩解压
tar
-x :extract解压
-c :create/compress 压缩
-t :test 只看看不解压
-v :versible打印详细信息
-f +path:目标文件
-z :用gzip,适用于.gz
-j :用bzip2,适用于.bz2
tar -xzf aaa.tar.gz :将aaa.tar.gz解压到当前目录
tar -czf aaa.tar.gz /bin :将/bin目录压缩到aaa.tar.gz

wget url :从网络下载数据，或者html
-i +filepath :按照文件中的url下载（批量）
-r :递归下载
-l num :递归层次

2013-8-3
2013-8-4
python:
import = include
import package.XX(引入模块中所有类和函数，模块即python文件.py)
from modle import func:从模块引入一个函数或类
模块搜索路径在环境变量中（添加可）:import sys sys.path.append("XXX")
package组织就是目录组织
import找package会从环境变量中找
def XXX(XXX,XXX) 定义函数
class classname(classname2):声明类并且继承自classname2
块不用大括号而用缩进表示块
__init__(self,...):表示构造函数，以_开头的方法都是名字修改，不能从外部访问，即private。一般__开头是特殊方法，特殊变量
构造函数内部应该手动调用父类构造函数,fatherclassname.__init__(...)
__name__如果是主程序则它的值为"main"
字符串是列表
类方法应添加参数self,调用不必赋值给它
类方法调用类方法或变量用self.XXX()，如果是声明在类中的，用classname.XXX形式，即static
循环有while() for r in XXX(列表，字典类型) = for(int i=0,r=XXX[i];i<XXX.length;i++){}
if() elif() else
#为注释
除了基本数据结构，列表即[]，元组()，字典{}均为指针或引用形式。
XXX[1:2]:复制XXX列表从第1到第2个数据的列表
如 a=3 b=a b=4 print(a) 结果是3，但a=[1,2] b=a b[0]=4 print(a) 结果是[4,2], 若 b=[1,2] b=[3,4],[1,2]这个列表会自动释放
字典形式{key1:value1,key2:value2,...},调用形式dict[key1]值为value1

java:
package = namespace
除内置基础类型之外都为引用(地址)
static=static
不存在定义类或者数组到栈空间
定义数组形式为int[] X=new int[n] :定义一个n长的数组，x在栈空间存储数组的地址，数组在堆空间存储数组本身
定义二维数组int[][] X=new int[n1][n2]，定义二维数组，x在栈空间存储数组的地址，数组在堆空间存储数组本身，x[2]表明第二个一维数组（引用）地址
不存在引用（地址）的运算跳地址的方法。
static类成员初始化就在类中
class a extends b :a类继承自b类，a为子类，b为父类
不允许多重继承
自动构造子类时先构造父类，也可以在子类构造函数显示使用super构造父类
super可以调用父类方法（可用于子类方法重写父类方法的情况下）= 父类::方法名
子类中不可访问的方法是不能被覆盖的
每个类都源自object类，如果无父类即相当于父类为object
java只能动态绑定，相当于每个方法都是virtual方法
instanceof :a instanceof b即如果类a实例的实际类是b则返回真，否则返回否

2013-8-5
java:
子类覆盖父类元素的时候，可能提升可见性，使父类protected覆盖为子类的public
final标识可让其不被覆盖或不被继承

2013-8-7
java:
异常产生如果不捕获即会造成进程停止。
有一些异常会由jvm自动产生，有一些通过关键字throw+异常类对象产生。
免检异常runtimeexception error，在throw此类异常的方法中不用一定声明，非免检异常一定要声明
try{}catch(异常类名 X){}finally{} 进入try后，finally无论如何都会执行，即使是try中遇到return
声明方法XXX() throws 异常类名
throw 异常类对象 ：抛出异常
异常会从发生异常函数开始，一直往它的调用者们传，直到到main函数或者其中有一个函数捕获。
异常处理是把异常产生和处理分离开的方法

2013-8-8
java:
abstract = virtual
如果类以abstract修饰，即为虚基类，函数被abstract修饰为纯虚函数，虚基类不能实例化，但能被继承，继承类如果没有实现完父类中的纯虚函数，也为虚基类。
接口以interface修饰类名，接口只能含有纯虚函数和静态常量，final是不能被继承的。
class XXX implement XXX2 :XXX2为接口，XXX实现接口XXX2相当于继承自XXX2且一定要实现接口的所有纯虚函数。
接口中的变量总是static final修饰，所以可省略，接口函数总是纯虚public函数，所以public abstract可省略
接口无构造函数
可多重继承接口
接口自身可以多重继承接口，为子接口。interface XXX1 extends XXX2,XXX3 :接口XXX1继承自XXX2,XXX3

2013-8-10
servlet:
tomcat的web应用目录结构:web-inf中有classes目录和web.xml和lib,web.xml控制web容器参数以及类（必在classes目录，classes目录中的类
可以调用lib中的类），<servlet>含servlet-name标签，servlet-class标签，servlet-name标签指定servlet名，servlet-class标签指定类名，
servlet-class必须是包名.类名。<servlet-mapping>含servlet-name标签，这个标签是索引servlet标签中的servlet-name标签的，还有个servlet-url
标签是说用户通过这个url访问就相当于访问servlet-class了。
按规定servlet类必须实现接口，init,service,destroy等四个方法，有几个类继承实现了几个规定接口和很有用接口，继承httpservlet类只需修改
doget,dopost方法就能控制servlet了。

spring:
ioc控制反转，将依赖关系写入xml，我们产生实例容器会自动读取xml产生相应实例，一定要以接口编程才有实质作用。spring本质就是一个jar库，实现相应功能。

mysql:
登陆mysql: mysql -u root -p --> 然后要求输入密码，登陆
查看mysql数据库中的所有数据库:show databases
创建数据库:create database 数据库名
转换到使用该数据库:use 数据库名
查看数据库中有哪些表:show tables
删除数据库:drop database 数据库名
创建表:create table 表名(列名 类型 其他属性,列名 类型 其他属性,...) 类型为数据类型，如int，varchar(40),其他类型如auto_increment,primary key,not null类型
查看表结构:desc 表名
删除表:drop table 表名
查询:select 列名 from 表名 where 条件 group by 分组列名 order by 排序列名 having 第二条件 limit 查询条数限制，多表查询表名间用逗号，列名用表名.列名表示
插入:insert into 表名 (列名1,列名2,...) values (值1,值2,...)
更新:update 表名 set 列名1=值1,列名2=值2,... where 条件
删除项:delete from 表名 where 条件
备份数据库:mysqldump -u root -p 数据库名 > 指定文件  :输入密码后将数据库备份到指定文件
恢复数据库:mysql -u root -p 数据库名 < 指定文件   :输入密码后将指定文件恢复到数据库，数据库必须存在

修改密码:mysqladmin -u root -p 旧密码 password 新密码
use mysql;
update user set password=passowrd('新密码') where user='用户名';
创建(更改)新用户权限:grant 操作(select 或 all privileges) on 作用数据库.作用数据表 to 用户名@host identified by "密码"; (%表示全部)
flush privileges; //刷新内存授权表
mysql数据库登陆数据和权限情况存在mysql库中的user表中

mysql数据库一般用操作系统中的mysql用户启动进程，如果用其他用户启动mysql --user=用户名
启动数据库mysqld --user=...&
关闭数据库mysqladmin -u root -p shutdown
跳过身份验证模式开启mysql服务mysqld --skip-grant-tables&

sql语句速记:
使用=,''表示相等以及字符串

内连接:from t1 inner join t2 on (t1.c1=t2.c2) :将t1与t2连接，按某列相交 = from (t1+t2) where t1.c1=t2.c2
左连接:from t1 left join t2 on (t1.c1=t2.c2) :将t1与t2左连接，按某列相交，会含有t1所有列，非相交的t1的行则该行中的其他列为空
右连接:from t1 right join t2 on (t1.c1=t2.c2) :将t1与t2右连接，按某列相交，会含有t2所有列，非相交的t2的行则该行中的其他列为空
全连接(交叉连接):from t1 full join t2 on (t1.c1=t2.c2) :将t1与t2全连接，按某列相交，会含有t1t2所有列

嵌套查询:from (select ... from t1 ...) t2 where t2.c1=... :将另一个查询t1表的结果作为t2表进行查询

group by condition :将condition返回相同的值的行合并为组，注意查询中的列除使用conditon以外的列，要用sum,count等这种聚合函数
group by c1,c2 :将c1,c2列相同的行合并为主
order by c1 desc 或 asc :按某列排序desc降序,asc升序
having condition 与where conditon :有group by分组的select语句，gruop by分组之前通过where将单一行为单位进行过滤，group by分组之后再通过having将分完组的group进行过滤一遍

SQL条件语句:
select c1,c2,if(condition,如果condition=true返回的值,如果condition=false返回的值) as c3 from ...
select c1,c2,case c3 when value1 then echovalue1 when value2 then echovalue2 else echoothervalue end as cName,c4 from ...
select c1,c2,case when conditon1 then echovalue1 when condition2 then echovalue2 else echoothervalue end as cName,c4 from ...

python 中修改数据库需要commit 

lsof命令

2013-8-11
php:
语法与c/c++类似，但不存在指针，存在引用，引用与c++引用类似，function XXX(&$a)定义引用形参即可传入实参的指针。
变量前面加$号。
双引号里的会解析变量，单引号里直接按原样输出。
\为转意字符，单引号里只能转单引号和自身。
内置预定义变量
$_SERVER['SERVER_ADDR']:服务器ip
$_SERVER['SERVER_NAME']:服务器名
$_SERVER['REMOTE_ADDR']:调用者ip
$_SERVER['REMOTE_PORT']:调用者端口号
$_SERVER['SCRIPT_FILENAME']:当前脚本的绝对路径
$_SERVER['SERVER_PORT']:服务器HTTP端口
$_COOKIE
$_SESSION
$_POST,$_GET,$GLOBALS
unset($a),如果a是某引用则解除引用将其设为null
$$a:以a变量值为名的变量值
字符串+号会将字符串转换为整形进行计算。强制类型转换与c相同。
.号是字符串连接，会将非字符串类型转换为字符串类型连接。
strlen,strcmp,substr,str_ireplace,str_replace,strncmp,strcasecmp与c相同

spring ioc:研究中

2013-8-14
javaweb:
servletconfig能通过getinitparameter,getinitparameternames函数来获取web.xml中的param。
web.xml中servlet标签中用<init-param>标签，其中用<param-name>和<param-value>来设置名字和值。
servletconfig可以得到servletcontext,servletcontext唯一标识了这个servlet的容器，其中可以给该应用中所有servlet共享数据。
比如setattribute,getattribute,removeattribute。
servletcontextlistener监视容器事件比如有contextinitialized可以捕捉servlet生成事件。

sdl:
在软件开发的整个生命周期都要进行安全检查。
数据访问1,要保证系统所给的数据不能有敏感数据，遵循最小权限原则，只能给业务所需要的最小范围的数据，能不给的字段就不给。
2，保证业务查询的时候只能查业务相关的那一条记录，不能任意查（可遍历权限之外）。
数据访问注意的威胁点，两个维度，一个是字段（横向），一个是任意（纵向）。
3，匿名业务（密码丢失找回密码业务等），存在身份认证的问题，单凭一个维度的挑战是不能确定身份的（比如找回密码只需提供身份证号，姓名），应该以多个相互对应维度
来认证身份（比如找回密码，要提供身份证号，提供证件复印件，某某时刻做过什么操作，手机号码等）。匿名业务也应该注意限制用户操作业务频度（比如用脚本不停执行匿名业务
的类似拒绝服务攻击），如一天内只能提交5次密码找回业务。匿名业务也要注意权限，不能该业务操作过程能访问其他用户的数据。
4，能不用匿名业务尽量不用匿名业务。
5，操作人员是否能被审计（建议）（比如云客满和外包的同学）。

3A:身份认证，授权，可审计
垂直权限：rbac，授权给该身份的用户哪些访问权限。水平权限：授权的时候给该用户哪些访问其他用户数据的权限。
独立的安全系统可以节约成本，业务开发人员更方便，业务开发人员门槛更低，业务开发人员调用服务，更易统一集中管理，维护成本低，抽象难度大。（构建和使用这个系统的难度，可行性，成本是最大问题）
个人见解：如果安全方案以及安全系统功能能很全面，业务开发人员就可以很方便的调用，如果将它的调用集成在开发框架内调用（比如框架中send自动加密，recv自动解密），更是不需要开发人员关心安全了。如果数据库中的每一条记录不仅存业务数据，
还必须统一封装成一个格式（开发框架完成，对开发人员透明），其中包含记录的敏感度，能被哪些角色访问（访问权限），已经被哪些用户在什么时候访问（可审计，相当于日志）等，可以省很多事。

2013-8-16
php的mysql数据库操作:
连接数据库:resource mysql_connect(string host,string usr,string password)如果返回的resource为false，可以后续用mysql_error()获得错误信息
选择数据库(相当于sql语句use database_name):mysql_select_db(string database_name[,resource conn])
执行sql语句:resource mysql_query(string sql)执行sql并返回结果集
设置结果集内部指针行数:bool mysql_data_seek(resource result,int row)之后fetch该数据集数据就从row行开始
获取结果集中的一行记录:array mysql_fetch_array(resource result)返回一个数组，索引是字段名
释放结果集:bool mysql_free_result(resource result)释放结果集的内存（脚本结束自动释放）
获得结果集中行数:int mysql_num_rows(resource result)
获得前一次sql操作所影响行数:int mysql_affected_rows([resource conn])主要用于insert update delete这种sql语句
转义一个要放入查询的语句使其安全:string mysql_escape_string(string sql_part)防止sql注入

php的xml操作:
将xml文件load进来解析:SimpleXmlElement simplexml_load_file(string filename)
比如一个这样的xml
<a>
	<d b="c">1</d>
	<d>2</d>
</a>
res=simplexml_load_file(xmlfile);
res->d[0]->attributes[b] == c;
res->d[1] == 2

数据安全（存储系统）
保密性：密文形式，加密处理
数据完整性：可以计算出是否被恶意修改，hash
数据源完整性（不可抵赖性）：该数据被谁创建，数字签名
可用性：在要用的时候能被访问到。

通信安全：
数据安全的那几个要素都需要。
实体完整性：通信双方的身份是确定的。

信息系统安全：
各种漏洞

sdl:
1,有些敏感信息业务要求需要查，要评估查这些敏感信息的风险，找到平衡点，太过就去掉。

2013-8-17
高信任区域，低信任区域。低信任域访问高信任域要做充分的安全检查。
信任边界:两个不同信任域的通信接口，在此处做足够安全检查。
缺乏信任导致了安全问题，安全系统是将信任取决与一个信任源。比如一个被完全评估的程序和协议(安全体系),以及一个大的机构政府(CA)。
信任扩散，此次可信任通信可以使下一次通信可信任。

没有安全的系统:1，人的配置;2，攻击手段进步

资产评估
威胁分析:漏洞点分析，攻击面查找。在每个环节检查访问点是否可以伪装(身份认证)，修改(数据完整性)，抵赖()，信息泄露，拒绝服务(可用性)，权限过大。
风险分析:造成的损失*利用难度
安全方案:从资产评估中获得资产的价值，威胁分析中获得漏洞点，风险分析中获得每个漏洞点的成本期望，资产值和成本期望做比较来确定用哪种级别的手段来修补漏洞。
安全方案最好做到透明。

secure by default:安全设置是默认设置
黑白名单:白名单比黑名单禁止范围更大。黑白名单是安全方案的基础。
最小权限:防止信息泄露和误操作。
全面纵深:每一层都需要考虑安全，即使攻破一层也不能获得什么。
数据代码隔离:防止注入漏洞，语义修改。编码和sql绑定都是这个原则。
随机性:防止重放和遍历。csrf属于重放攻击。

PWN2OWN

php:
form hidden隐藏域用来存储不需要看到的数据，提交时也提交到服务器
name=value对
id作用于javascript
默认日期时间是UTC格林威志时间，通过php.ini或者函数设置时区(用于date)。
timestamp是unix时间戳，记录从1970.1.1到某个时间点的秒数。

2013-8-18
同源:页面和页面之间的服务器ip，域名，端口，协议(http)都相同。
同源策略:不同源的页面代码之间不能互相访问。
GET/src:通过发送GET方法获得的图片，脚本等不受同源策略影响。比如script,img,link等。
加载的不同源script:权限小于同源的javascript,不能访问本页面资源。
一个域中xmlhttprequest跨域访问另一个域的内容，可通过http头来确定有没有该权限，申请权限。
浏览器第三方插件不受同源策略影响，但一个好的插件比如flash,java applet都有自己的同源策略控制，比如flash在进行不同源访问时，会读取目标crossdomain.xml
查看有无访问权限。

@import加载css会出现同源策略被绕过的情形。
挂马:网页中有一段恶意代码，利用浏览器(也可以是插件)漏洞，浏览器下载执行后执行任意代码。比如通过script,iframe加载恶意网址，或通过恶意javascript或flash
代码，利用浏览器漏洞(包括插件和控件漏洞)执行shellcode，在电脑中植入木马。
sandbox:代码放在一个沙箱环境中执行，代码要访问外部资源，必须调用沙箱专用api，请求在api中会经过严格检查
浏览器多进程:浏览器内核进程，各第三方插件进程，tab页进程(沙箱中)
对抗恶意网址:服务器持续不断搜集恶意网址集合形成黑名单，定期推送给浏览器，浏览器url匹配黑名单。
evssl:是现有x509证书的超集，CA与浏览器厂商合作，CA发布的这种ssl证书，浏览器可认为是可信的，一般浏览器会在这个url上打上大大的勾勾。
csp:在获取页面时，通过http的一个字段告知浏览器一个白名单，该页面只会读取这里面有的数据，如果读取了其他的则拒绝(说明页面被修改了)。
通过http获得权限信息和白名单要在能保证脚本不能提前修改http头的前提下。


php:

2013-8-19
tcpflow/pf_ring:
rx:下行数据(r=recv)
tx:上行数据(t=transmit)
char *strchr(char *s,char c):字符串s中第一次出现c的位置返回该指针
strtok

2013-8-23
2013-8-24
2013-8-26
2013-8-31
php:
NULL,false,'' == 0
true类型转换后为1
true进行逻辑判断时与非0等同，10==true答案是true(1)
isset与变量内存有关,如果有引用的值则返回1，无则0。0==isset(($var=NULL)),0==isset($var2),var2未定义赋值。
empty与变量值有关,等价于0的值均返回1，empty($var)相当于$var==0

c:
NULL,FALSE在内存中都是0,TRUE在内存中1表示
#define NULL ((void *)(0))
#define TRUE (1)
#define FALSE (0)
NULL,FALSE == 0
TRUE == 1，10==TRUE答案是FALSE(0)

2013-9-1
charset:
ascii:1个字节表示，0--127编码，其中低0--31为控制编码，不可见编码。
ascii扩展:一个字节表示,0--255均编码，扩展了可打印字符。
GB2312:中文字符集，2个字节表示，含英文字母，符号，中文，日文等。低位字节为偏移量(0xa1--0xfe)，高位字节为区位(0xa1--0xf7)。
GB18030:GB2312扩展，变长编码(有1字节，最长4字节)。
BIG5:大5码，繁体中文编码，2个字节表示。
unicode:unicode编码，2字节表示所有符号。
utf-8:unicode编码方式之一，变长编码，1字节兼容ascii编码，其他字母2字节，汉字3字节，有些4字节。(兼容ascii使得可兼容老机器
，网络传输常用)。
utf-16,utf-32:unicode编码之一，但不常用

encode:
urlencode:编码url，将非7位ascii码，包含&,=,%,/,\等特殊符号，按照某种字符集编码为%H,H为16进制数。url在浏览器发送时自动编码。可一定程度上防止sql注入,xss注入。
htmlencode:编码html文档，特殊字符，如<,>,空格等用&+字母表示，如<就编码为&lt。浏览器在view层时会自动解码html文档。能防止xss注入。
javascriptencode:编码javascript代码，特殊符号用\编码，类似于c语言字符串转义。javascript在确定语义之后，会自动将javascript解码。
base64:将任意2进制数据编码为可显示ascii码字符，更直观。
unix文本格式:换行符为\r\n，dos2unix可将windows文本格式转换为unix文本格式
dos/windows文本格式:dos/windows的换行符\n

2013-9-8
xss:

2013-9-12
xss:
1，就是html注入，既然是注入漏洞，成因就是代码和数据没有隔离好，用户的输入改变了html文档语义。
2，反射型xss:没有将xss代码存储在服务器上，要诱骗让别人点击一下xss链接，或者是和存储型xss捆绑触发。
3，存储型xss:xss代码存储在服务器上，用户访问服务器上含有xss代码的页面时自动触发。有较强稳定性，破坏力强。
4，dom xss:javascript根据用户输入修改页面dom，修改了该页面html代码造成了xss漏洞。(反射型xss)
5，xss payload:在含有xss漏洞的代码段插入特定xss payload将会完成不同功能。比如盗用认证cookie，以受害人身份执行操作，获取用户信息等。
6，cookie httponly:标记可以使除http访问正常发送接收cookie之外其他途径均不能读取到cookie。
7，xss 蠕虫:本质上不仅有破坏代码还有传播代码。
8，xss漏洞技巧:meta中或者浏览器解析的字符集编码和服务器发送来的html文档内容所使用的字符集不匹配时，通过提交设计好的数据可以绕过输入转义。
绕过长度限制的方法:在html标签内的xss漏洞可以使用事件减少xss代码长度。通过<script src="XXX">的src加载payload。通过location.hash来藏代码。
9，windows.name有跨域。
10，xss防御方法
输入检查
输出检查
输入编码:html编码后在浏览器html解析确定代码语义结构后解码html的编码，输出到浏览器上。xss代码因被编码转义而失去改变语义的作用，等到语义确定再解码
起到了数据和代码隔离的作用。javascript编码是在javascript解析确定javascript语义后再解码的。先html解码再javascript解码。1)用户输入代码输出到html中的
用html编码，输出到javascript代码中的用javascript编码。dom xss需要分阶段考虑，大体思路还是输出的dom是在html中用html编码，在javascript脚本中用
javascript编码。

2013-10-11
php:
string pack(format str,可变长参数(类似于数组)):将可变长参数以format str所示打包成相应位串(也是字符串)。
数组 unpack(format str,string):将位串(字符串)以format str所示拆分成数组。
ruby形式:
string=[a,b,...].pack("format str")
string.unpack("format str")==[a,b,...]
format str:
a 一个填充空的字节串
A 一个填充空格的字节串
b 一个位串，在每个字节里位的顺序都是升序
B 一个位串，在每个字节里位的顺序都是降序
c 一个有符号 char（8位整数）值
C 一个无符号 char（8位整数）值；关于 Unicode 参阅 U
d 本机格式的双精度浮点数
f 本机格式的单精度浮点数
h 一个十六进制串，低四位在前
H 一个十六进制串，高四位在前
i 一个有符号整数值，本机格式
I 一个无符号整数值，本机格式
l 一个有符号长整形，总是 32 位
L 一个无符号长整形，总是 32 位
n 一个 16位短整形，“网络”字节序（大头在前）
N 一个 32 位短整形，“网络”字节序（大头在前）
p 一个指向空结尾的字串的指针
P 一个指向定长字串的指针
q 一个有符号四倍（64位整数）值
Q 一个无符号四倍（64位整数）值
s 一个有符号短整数值，总是 16 位
S 一个无符号短整数值，总是 16 位
u 一个无编码的字串
U 一个 Unicode 字符数字
v 一个“VAX”字节序（小头在前）的 16 位短整数
V 一个“VAX”字节序（小头在前）的 32 位短整数
w 一个 BER 压缩的整数
x 一个空字节（向前忽略一个字节）
X 备份一个字节
Z 一个空结束的（和空填充的）字节串
@ 用空字节填充绝对位置
c3表示3个c的format
c*表示均是c的format

sar -n DEV interv count:显示所有网卡流量信息，每interv更新一次，更新count次。
top -d interv -p pid:显示pid进程的占用资源情况,每interv更新一次。
ulimit -c size:遇到11信号进程(段错误)，将产生coredump文件，coredump文件小于size大小，size设为unlimited表示无限制
chmod 777 core.XXXX && gdb 错误进程 core.XXXX:调试错误，bt可查看堆栈信息。

2013-10-13
csrf:
1，用户访问一个页面或者点击一个url，由于页面中或点击的url有csrf漏洞，导致攻击者以用户的身份执行了操作（一般增删改操作）。
2，csrf条件:
a)用户认证(因为要以用户的身份执行操作)，用户已产生通过认证的session cookie或有通过记住密码产生的本地cookie。与img iframe script link等标签的src不同源的页面产生的读取这些img iframe script link的get请求不会提交这些源的本地cookie,
会提交本地cookie。这是浏览器保护用户信息的行为（一般本地cookie中有认证信息）。如果攻击者设置页面，然后以img iframe script link产生url，就需要用户之前得到通过认证的session cookie，而
有本地cookie是没用的，例外是如果产生该url的源是P3P头认为与目标是可信任的，那么相当于它们是同源的。匿名的操作不需要用户认证。
b)url本身可预测，也就是缺乏随机性。
3，post方法的csrf，攻击者诱使用户访问他的攻击页面。攻击页面加载攻击者写好的js,该脚本自动提交指定表单到目标服务器就能完成post方法的csrf。
4，csrf蠕虫，所谓蠕虫就是有传播功能。一般传播模块使用csrf。
5，防御csrf:
a)验证码:用户在执行某个操作的时候必须输入验证码或某种提醒。
b)referer:用户执行操作时检查提交url的referer字段，如果不是来自可信任源就拒绝掉。这种方法问题是referer是可被用户选可修改的。这个方法倒是可以用来监控。
c)使用token:产生csrf的条件就是有一条是url本身是可预测的，缺乏随机性。我们可以增强url的随机性，动态性来解决csrf问题。服务器在页面上添加一个隐藏表单，内容
是token随机值。服务器在自己session中或者用户浏览器cookie中添加该token。用户提交一个操作时，会提交隐藏表单中的token，再和session或者cookie中的token比对
验证。注意token不能被预测到，最好不要在url传输token，因为容易被代理，referer，和历史纪录中泄露token。

2013-10-19
java:
1，jvm其实体就是/bin/java程序。
2，javac XXX.java:编译XXX.java为XXX.class，将XXX.java源代码编译成java虚拟机可执行的XXX.class字节码。
3，java XXX:执行XXX.java或者XXX.class中的main
4，1个XXX.java中只能包含一个外部可见的类，且该类名必须跟文件名一致。因为它被编译出来XXX.class是以类做单位的。
5，编译或执行java程序时需要环境变量JAVA_HOME，CLASSPATH。安装时需加环境变量。其中CLASSPATH是编译或执行java程序时需要用到的
依赖.class的路径。
6，package命令实验(在/root/java中实验)：
package A.B.test;
public class test{...}
a)将该test.java存在/root/java中，javac /root/java/test.java编译成功得到/root/java/test.class
b)java test执行错误，原因是test.class使用了package A.B.test。必须要在/root/java/A/B/test.class才行。
c)将test.class置于/root/java/A/B/test.class
d)java test执行错误，java A.B.test成功，cd ./A/B && java test执行失败，java /root/java/A/B/test失败，
java root.java.A.B.test失败，java执行时将/转化成.
e)java /root/java/A.B.test
结论：
1)javac编译.java文件对package指令没有任何限制，它只在.class文件留了这个信息，它是在A.B包里。
2)包的实体是路径层次，所以定义该文件在A.B中，一定要把.java文件放在A/B/里面。
3)java程序在使用/或者.号时一律转化为.号，从当前java工作目录中以输入的.号作为路径找到test.class并执行，执行时得到其中的包
信息，再从当前目录按package指令所指定的包信息找test.class。
import命令:javac和java执行时会按classpath+import路径找相应的包进行编译或执行。import命令其实就是替换调用的类名称，比如
import A.B.test;test testi=new test();其实test testi=new test(); = A.B.test testi=new A.B.test()。

javac命令详解:
javac [option] [sourcefile] [@sourcefilelistfile]
option: 编译选项
sourcefile: 源文件，即.java文件
sourcefilelistfile: 源文件列表文件，所需要编译的源文件路径可放在其中
sourcefilelistfile形如:
path/aaa.java
path/bbb.java

执行结果: 生成.class文件

-classpath: 指定编译所需要类文件，包文件（也可是源文件）所在路径，指定该选项将不再使用环境变量CLASSPATH；默认是javac工作目录。用;进行路径间分隔。
-sourcepath: 指定编译所需源文件（也可是类文件和包文件）的路径。用;进行路径间分隔。
-d: 指定生成编译好的.class文件的输出目录，注意：该选项会根据编译好的类文件所指定的包结构在指定路径下面自动生成包路径。如果没有指定该选项，会在源文件目录下面生成.class，使用时还需自己根据其包结构手动生成包路径
-g: 生成所有调试信息
-O: 优化代码，减少执行时间，注意：一般不和-g一起使用
-verbose: 冗长输出
-target: 指定生成的类文件在哪个版本的java虚拟机执行，形如1.2 1.6 1.7
-bootclasspath: 指定自举类路径，以;分隔路径
-j: 指定执行该编译.class文件传入给java虚拟机的选项，形如-j-Xms48m
-X开头的选项: 非标准选项

eclipse独有编译文件:
.classpath文件: 包含源文件路径(kind="src")，输出文件路径(kind="output")，系统环境相关信息(kind="con")，库文件路径等路径信息(kind="lib")，最终编译时还原为-classpath -sourcepath -d选项路径。
.project文件: 包含描述工程的信息，如工程名，工程注释，额外eclipse插件等。
.setting: 包含插件所需配置信息

java命令详解:
java [option] [classfile|(-jar jarfile)] [argument]
option: java虚拟机选项
classfile: 所要执行的类文件
jarfile: 所要执行的jar文件，jar文件中以哪个类开始执行，由jar包中META-INF/MANIFEST.MF清单文件中Main-Class选项决定
argument: 传入程序的参数
执行结果，开始执行java程序

-classpath: 指定编译所需要类文件，包文件所在路径，默认是java工作目录。用;进行路径间分隔。
-D: 设置系统属性值，形如-D属性=属性值
-verbose: 冗长显示，形如-verbose:jni，显示代码接口活动信息
-X开头: 非标准选项
-Xbootclasspath: 指定自举类路径，以;分隔
-Xmsn: 指定内存分配池的初始容量，形如-Xms16m，16m初始内存，默认为1m
-Xmxn: 指定内存分配池的最大容量，形如-Xmx512m，512m最大内存，默认为16m

注意，java命令执行的classfile一定要以.class所指定的包路径执行
如test.class在/path/A/B/test.class上，包路径指定为package A.B.test，则执行test时要用java /path/A.B.test

jar包中的清单文件META-INF/MANIFEST.MF
Manifest-Version: 用来定义manifest文件的版本，例如：Manifest-Version: 1.0
Created-By: 声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1
Signature-Version: 定义jar文件的签名版本
Class-Path: 应用程序或者类装载器使用该值来构建内部的类搜索路径
Main-Class: 定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。

签名相关属性
Name: javax/mail/Address.class
Digest-Algorithms: SHA MD5
SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=
MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw==
这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE64方法进行编码)

jar命令详解
打包与tar命令相似多了-m参数指定MANIFEST.MF文件

maven使用详解
mvn [plugin1:object1] ... [plugin1:object1]
mvn命令在工作目录中有pom.xml的地方执行，pom.xml定义了该项目所有信息，包括项目信息，依赖信息，插件信息。
mvn使用src/main/java作为源码路径（构建作为sourcepath）,使用src/test/java作为测试项目的源码路径（在测试阶段作为-classpath）,
使用target/classes作为编译输出路径（作为output路径，javac -d参数，jar打包路径），target/test-classes作为测试编译输出路径。
pom.xml输出的依赖项加入到-classpath路径，依赖包若本地仓库没有，就会从远程仓库（可在pom.xml中配置）下载到本地仓库。
-/
|
--src-main-java-XXX.java
       |
      test-java-testXXX.java
--target-classes-XXX.class/XXX.jar
            |
        test-classes-testXXX.class/testXXX.jar
--pom.xml

mvn命令在构建项目时

pom.xml结构：
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.alipay.security</groupId>
	<artifactId>dbaudit</artifactId>
	<version>0.0.1-PROD-NOSQL</version>

	<dependencies>#项目依赖的外部包
		<dependency>
		  <groupId>zql</groupId>
		  <artifactId>zql</artifactId>
		  <version>1.0</version>
		</dependency>

		<dependency>
			  <groupId>junit</groupId>
			  <artifactId>junit</artifactId>
			  <version>4.8.2</version>
			 <scope>test</scope>
		</dependency>
	</dependencies>
	
	<repositories>#远程代码仓库配置
		<repository>
			<id>clojars.org</id>
			<url>http://clojars.org/repo</url>
		</repository>
	</repositories>		
	
	<build>#构建配置
		<plugins>#插件配置
			<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-compiler-plugin</artifactId>
					<configuration>
						<source>1.6</source>
						<target>1.6</target>
					</configuration>
				</plugin>
			</plugins>
  </build>        
</project>

mvn clean compiler:compile :编译.class文件
mvn clean test:test :测试项目
mvn package:package :打包
mvn install:install :将该项目的包放在本地仓库中
mvn eclipse:eclipse :生成eclipse项目，生成.project,.classpath，可导入eclipse
mvn archetype:generate :生成mvn项目的路径框架（会进行交互）

2013-10-24
df -hl:查看系统分区挂载情况。
h:human以人类看的方式显示
l:list列表出来

du --max-depth=num -l XXX:查看XXX路径下num目录深度的磁盘占用量。
num:深度
l:list列表

fdisk XXX:查看或格式化某块设备,XXX为某块设备,如/dev/...。
之后按照提示做。
-123M

mkfs.vfat XXX:格式化XXX块设备分区为fat32。
mkfs.ext[2--4] XXX:格式化XXX块设备分区为ext[2--4]。

2013-10-27
cron:linux定时任务 (注意cron启动的任务环境变量都是空的，一般要用su --login [root|other] "command"来执行命令，赋予环境变量)
service crond start:打开定时任务
service crond stop:关闭定时任务
crond每分钟读取/var/spool/cron/目录下与用户同名的文件，该用户定时任务信息记录在里面。匹配看是否执行。
crond同时每分钟读取/etc/crontab文件，这是系统任务，匹配成功则执行。
/etc/corntab文件修改自己用vi修改
crontab命令增删改某个用户的定时任务。
1)-u XXX:设定XXX用户
2)-l:列出定时任务详情
3)-r:删除XXX的定时任务
4)-e:编辑XXX的定时任务
格式:* * * * * cmdline
从第一个*到第5个*分别代表分(0--59),时(0--23),日(1--31),月(1--12),星期(0--6)
'/',',','*','-':这3个特殊符号*表示所有，/表示每，','表示和,'-'表示到如下:
0 23-7/2,8 * * * echo "hello" >> /dev/null:晚上11:00到早上7:00每两小时执行一次，早上8:00执行一次
/etc/crontab格式:
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/
#下面是具体ITEM
01 * * * * root run-parts /etc/cron.hourly
#run-parts:执行目录下所有脚本。
#这句的意思是每个小时的01分以root用户执行/etc/cron.hourly目录下的所有脚本。

2013-11-19
开机自启动:
1,/etc/rc.d是自启动脚本的目录。
2,/etc/rc.d/rc0.d,/etc/rc.d/rc1.d,/etc/rc.d/rc2.d,/etc/rc.d/rc3.d,/etc/rc.d/rc4.d,/etc/rc.d/rc5.d,/etc/rc.d/rc6.d这7个目录中存有
/etc/rc.d/init.d（一般情况）目录下启动脚本的符号链接。系统启动时会根据/etc/inittab中的启动id号选择其中一个/etc/rc.d/rcX.d中的脚本执行。执行时
按照S{number}{name}或K{number}{name}执行，其中执行先后为number越小越先执行，S开头的执行时用start作为参数，K开头的用stop作为参数。
3,/etc/rc.d/rc.local脚本的符号链接是已经加进/etc/rc.d/rc{1--6}.d目录，一般符号链接名为S99local，所以如果要想一个程序自启动，直接在/etc/rc.d/rc.local
脚本中写入即可。
4,/etc/profile会在一个tty（会话）打开，初始化bash（shell）时执行，接下来执行~/bash_profile内的脚本。

用户管理:
/etc/passwd存储用户信息，每行一个用户，取一行举例
root:x:0:0:root:/root:/bin/bash
其中每一个项之间以冒号分隔，从左到右项的意义依次是用户名，密码(x是占位符，真实密码是加密存于/etc/shadow中的)，uid(管理员都是0,系统内部是以uid号表示用户的)，gid，
描述信息(系统不管)，用户home目录，用户所使用的shell。
uid为0的用户一律有root权限。
/etc/shadow存有用户口令信息，每行一个用户，以一行举例
root:$6$b9aGlgigJtREMPYj$nHZIGTfvAsTBIiigEODMNsmKL.QZNqi5KpLK.kWSdv8kMUQdSFRKMd.c8eiKxcWbLfKd4swfnl4oyndd8bZft1:16002:0:99999:7:::
其中每一个项之间以冒号分隔，从左到右项的意义依次是用户名(作为与/etc/passwd映射关系的值)，密码(加密形式)，上次更改密码时间(粒度为天)，密码不被改动的天数，
密码需要重新更改的天数，密码到期前几天提醒，帐号失效期(应该改密码却没有改，被锁定)，帐号取消日期(这个日期后该帐号就不可用了)，保留。其中密码项如果首字符为
*号表示该帐号不用于登录，某进程可用它执行，首字符为!表示该帐号被禁用，首字符为!!表示新创建的账号后还未设置密码该账号就是禁用登录状态，该密码为空表示可不输入密码登录。
/etc/group存储组的信息，每行一个组信息，取一行举例
daemon:x:2:bin,daemon
其中每一个项之间以冒号分隔，从左到右项的意义依次是组名，群组密码(一般不设)，gid，群内用户(以,分隔，如果/etc/passwd文件用户gid已经设为该群组id，即可在此省略该用户，默认有)
命令:
创建用户:adduser [-u uid][-g group][-d home][-s shell] 用户名
过程:插入用户名到/etc/passwd，插入/etc/shadow(密码为!!)，如果没设定组且没有同名组，插入/etc/group，创建/home/user，并将/etc/skel中的配置文件复制到/home/user。
设置密码:passwd 用户名
过程:执行过后会让你输入密码，如果/etc/shadow里面为!!，输入两次密码，如果不为!!，输入旧密码后输入两次密码，将新密码加密后放于/etc/shadow
删除用户:userdel [-r] 用户名:-r会删除宿主目录。
添加用户组:groupadd
修改用户属性:usermod
删除用户组:groupdel

2013-11-20
文件上传漏洞:

2013-11-27
SQL注入技巧:
-- :为注释符，XXX' or 1=1-- 这样就能返回所有的数据。
insert注入:因为不知道原始SQL有多少个列，所以不断尝试XXX')--,XXX',1)--,XXX',1,1)--
update和delete注入要特别小心破坏原始数据。
%分号为通配符，在有些地方(搜索位置输入)会返回所有数据。
字符串注入:输入'会出错，''正常的返回则有注入，连接字相当于输入XXX，oracle:'||'XXX，mssql:'+'XXX，mysql:' 'XXX怎样如果返回结果与直接输入XXX相同则有注入。
如果XXX' and '1'='1与输入XXX相同而XXX' and '1'='2返回空，则有sql注入。
数字注入:如果1+1或3-1与输入2相同，67-ASCII('A')如果与输入2相同或者51-ASCII(1)与输入2相同，则有sql注入。
如果XXX and 1=1与输入XXX相同而XXX and 1=2返回空，则有sql注入。
order by注入:order by XXX ASC表明按照XXX列以ASC排序，XXX为1，2，3这与select当中的返回列第1，2，3列队等，所以可以输入1，2，3...看是否每次返回一致但顺序
不同，如果输入的整数大于select的查询列数则返回失败。输入1 ASC --与1 DESC --是否返回一致但顺序相反。
整数可以隐式转换成字符串，字符串不能隐式转换成整数，NULL可以隐式转换成任意类型。

2014-1-28
通配符：
*:匹配0或多个字符
?:匹配单一字符
[abc]:匹配{a,b,c}集合中的一个字符
[^abc]:匹配非{a,b,c}集合中的一个字符
[a-c]:匹配{x|c>=x>=a}集合中的一个字符
[[^a-c]:匹配非{x|c>=x>=a}集合中的一个字符
{str1,str2}:匹配{str|str==str1||str==str2}集合中的一个字符串
\c:转义字符，匹配元字符c

2014-3-11
正则表达式：
正常字符（abcdefg等）：匹配相应字符。
元字符：\某字符，或*.字符，表达某种特殊代码。

代替字符：
. :匹配除换行符任意字符
\w:匹配字母，数字，下划线或汉字
\s:匹配任意的空白符
\d:匹配一个数字
\b:匹配一个单词开始和结尾
^:匹配字符串开始
$:匹配字符串结尾

重复字符
某字符{n}:某字符重复n次
某字符{n,m}:某字符重复n到m次
某字符{n,}:某字符匹配>=n次
某字符*:某字符重复0次或多次
某字符+:某字符重复1次或多次
某字符?:某字符重复0次或1次

\:转义字符，消除其后一个字符的特殊意义

集合字符：
[abc]:匹配一个在abc集合中的一个
[a-z]:匹配a-z集合的一个字符
[0-5]:匹配0-5的数字
[^0-5]:匹配非0-5集合中的东西

逻辑字符：
正则1|正则2:字符串只需匹配正则1和正则2其中之一即算匹配

分组字符:
(\d{3}){2}:括号，代表其为一个整体，且可用group()函数来获取括号中的字符串

反义:
\S
\B
\W:
\D
^

贪婪与懒惰：
一般情况在重复匹配过程中，默认匹配最长匹配最长，在重复匹配字符后加?则变为匹配最短。

match与search (find)模式 :
match要从字符串开头匹配，search模式可从字符串任意位置匹配

2014-3-15
xargs命令

python注意点：
整数除法与C相同，即1/2=0，1.0/2=0.5
取余运算符%可适用于浮点数。
**为乘方的意思，(-3)**2==9
16禁止表示:0x,8进制以0开头的数字。
python有内建函数，pow,abs,round等

import XXX
XXX.aaa()
如果XXX模块中含有aaa函数，会找到XXX.aaa调用XXX.aaa()函数。
from XXX import aa
aaa()

这样就不需要XXX前缀了。

int(1.0)==1 :强制类型转换。
可以变量引用函数，foo=math.sqrt foo(4)==2
nan:not a num的特殊值

unix:
#!shell_path:让该文本文件用指定程序作为参数执行，该文件有可执行权限。

#为注释符
字符串中"和'是一样的意思，字符串中\为转义字符，\还可以用于跨行。
字符串拼接：str1+str2，str1和str2必须为字符串，不然应强制类型转换。
强制类型转换为str:str(x)以合理的方式转换，repr(x)以合法的方式转换。
r'xxx':r作为前缀，xxx就为原始字符串。
u'xxx':xxx为unicode字符串
数组下标从0开始，-1是最后一个元素。
字符串也可作为数组操作。
数组是个广义表[aaa,bbb,'a',[33,22],(11,22)]这种
字符串索引求值仍然是字符串，python没有字符的概念。
数组分片aaa[3:8] 8>索引值>=4的值，[3:] ==索引大于3的值，[:3] ==从串头到3的值
分片步长aaa[3:8:2],步长为2，步长可为负，负从后遍历
序列相加[1,2,3]+[4,5,6]=[1,2,3,4,5,6]
序列乘法
None为什么都没有的特殊符号
32 in [1,2,32] == True
32 in [1,2,3] == False
len([1,2,3])==3
max([1,2,3])==3
min([1,2,3])==1
字符串项不能被修改，'12345'[2]=3 :错误
list('123')==['1','2','3']

aaa=[1,2,3]
del aaa[1]
aaa==[1,3]

默认aaa==[1,2,3]


aaa[:2]=[100,200]
aaa==[100,200,3]

aaa[1:1]=[100,200]
aaa==[1,100,200,2,3]

aaa[1:2]=[]
aaa==[1]

aaa.append(100)
aaa==[1,2,3,100]

aaa=[1,1,2]
aaa.count(1)==2

aaa=[1,2,3]
aaa.extend([100,200,300])
aaa==[1,2,3,100,200,300]

aaa.index(2)==1
aaa.index(100) :error
aaaa.insert(1,100)
 <==>aaa[1:1]=[100]
aaa==[1,100,2,3]
aaa.pop()==3
aaa==[1,2]
aaa.pop(0)==1
aaa==[2,3]
aaa.remove(2)
aaa==[1,3]
aaa.remove(100) :error
aaa.reverse()
aaa==[3,2,1]
aaa=[3,1,2]
aaa.sort()
aaa==[1,2,3]

aaa=[3,1,2]
bbb=aaa
aaa.sort()
bbb==[1,2,3]

aaa=[3,1,2]
bbb=aaa[:]
aaa.sort()
bbb==[3,1,2]       

元组 (1,2,3)，一个元素(1,)
tuple([1,2,3])==(1,2,3)

'aaa %s a %s bbb'%('xxx1','xxx2') == 'aaa xxx1 a xxx2 bbb'
%d,%f,%x,%u,%o,%r
%-a3.2f:长3，精度为2的浮点数，且左对齐,不足用a填充

aaa.find('1',1,2) :寻找字串，如果有返回字串位置，没有返回-1,从起始点1，结束点2中间查找。
起始中止都是前闭后开区间

join方法是split逆方法
a=['aaa','bbb']
b='+'
b.join(a)=='aaa+bbb'
b=='aaa+bbb'

lower:字符串全变成小写

aaa='is a girl'
aaa.replace('girl','boy')
aaa=='is a boy'

split
'1+2+3'.split('+')==['1','2','3']

strip:去除字符串两侧的空格等
strip('!*'):去除两侧指定字符，包括空格
lstrip,rstrip

table=maketran('ab','cd')
aaa.translate(table,' '):将a转换为c，将b转换为d，同时去除空格，第二个参数可选。

字典：hash表
{key1:value1,key2:value2}

dict函数
dict([(aaa1,bbb1),(aaa2,bbb2)])=={aaa1:bbb1,aaa2:bbb2}
也可跟其他dict，相当于copy
dict(aaa1=bbb1,aaa2=bbb2)=={aaa1:bbb1,aaa2:bbb2}

键值必须为不可变类型，比如字符串和元组
自动添加，如果索引键值不存在，自动添加映射
k in d:检查键值k是否在d中

'aaa is %(title)s'%{'title':bbb} =='aaa is bbb'

clear，清空dict
copy方法，浅复制，value不会复制，只会复制指针
deepcopy函数，深复制：from copy import deepcopy
fromkeys方法:以指定的键值创建dict
get方法:获取指定键值，即使键值不存在，返回None
has_key:in操作符一致
items方法，以列表，项是元组的方式返回
keys，以列表方式返回键值
aaa.pop(key):返回key所对应的值，并删除key项
popitem:随机返回删除一个值。
setdefault(key,value)方法:如果已有key，返回key对应值，没有则添加key->value对
updates方法，可用参数与dict一致，如果参数中所含项不在目标dict中，则添加，否则则更新
values:返回值的列表

import XXXmodule as aaa
import XXXmodule.XXX2module
from XXXmodule import XXXfunction as aaa
from XXXmodule import *

(x,y,z)=(1,2,3)
x==1,y==2,z==3

可用+=,*=运算符
语句块以:开始，之后每句话都要缩进，可用tab也可用空格，一般用空格4个来缩进

False None 0 "" () [] {} 转换为布尔值解释为False,其他为True
if condition :
    XXXX
else:
		XXXX

elif condition:

比较运算符:
==
>=
<=
>
<
!= <>
is :不是同一对象（指针）
is not
in
not in
只有相似对象才能比较
比较运算符可连接:a<x<b
字符串比较是以字典顺序比较的

逻辑运算符:
and or not
短路逻辑:a and b如果a为假b就不执行了，a or b如果a为真b就不执行了

assert condition:如果condition为False就退出程序
range xrange(a,b):产生从a到b的一个序列

for a in b:是a=b当中的一个元素
zip([aaa,bbb],[xxx,yyy,zzz])==[(aaa,xxx),(bbb,yyy)]
enumerate([aaa,bbb,ccc])==[(0,aaa),(1,bbb),(2,ccc)]

[x*x for x in xrang(0,10) if x%2==0] == [0,4,16,36,64,100]

del aaa :释放aaa的名字，解除aaa引用

exec aaa :将字符串aaa作为代码执行
给exec设置作用域:
scope={}
exec aaa in scope
eval(aaa,scope):将字符串作为代码执行，返回值
双下划线的属性名是有特殊意义

函数定义
def funName(aaa,bbb):
	  pass
return xxx
若没有return或return空，则返回None

funName(aaa=AAA,bbb=BBB)

默认参数
def funName(aaa=AAA,bbb=BBB):
		pass
vars()返回当前作用域内的变量字典
locals():返回局部作用域变量字典
globals():返回全局作用域变量字典

__metaclass__=type:使用新式类
class ClassName(ClassName1,ClassName2): #继承自ClassName1,ClassName2
    classParam=xxx
    def fun1(self,aaa):
        something
    def __kkk(self):
        ClassName.ccc=ccc1 #相当于static属性
        something2
    @staticmethod
    def stfunc(aaa)
self是自身类对象的引用
用__开头的函数和属性，外部没法直接引用，其名字被重写成_类名__方法名，属于私有的
单下划线函数或名字，不会被import *引入
aaa=ClassName():创造对象
类名.__bases__ 可返回所有基类
issubclass(子类名，父类名)==True
isinstance(对象名，类名)==True
对象名.__class__:返回所属类字符串
hasattr(对象名,属性名)，返回BOOL
getattr(对象名，属性名,None)返回该属性的对象
setattr(对象名，属性名，value)设置属性名value
hasattr(属性对象，'__call__')看属性对象是否可执行
对象.__dict__ :返回对象内所有属性值

如果未捕捉异常类，就会traceback退出程序
raise ExceptionClassName ：抛出异常
所有异常都是Exception的之类
try
catch (E1,E2) as e
else
final

raise
raise E3

若一个方法是__XXX__的方法，是一个特殊方法，系统会在特定时间调用。
__init__方法，构造方法
super(子类名,self).__init__()

实现__iter__为可迭代对象，实现next为迭代器，如果next到最后了应该raise stopiterator异常

import 模块名 ：会将模块名.py文件内的函数，类导入到模块名命名空间。会执行一遍该文件内的内容。
如果是直接执行模块名.py，其__name__是__main__字符串，如果是导入的话__name__是模块名字符串
模块必须在sys.path或系统PATH环境变量中才能被python找到
包就是一个文件夹，里面包含很多模块名.py，以及一个__init__.py
import 模块名，只是将其命名空间和其中的函数导入

2014-4-10
\n:unix换行符
\r\n:windows及http换行符

2014-4-20
sqlite: 文件格式化为数据库，可用sql语句建表，查询，插入，更新且可加锁

python打包为exe或linux的可执行程序：
使用pyinstaller程序
1,下载pyinstaller在http://www.pyinstaller.org/
2,编写要打包的/path/xxx.py文件，使用python /path/xxx.py [argument]可执行即可
3,使用python pyinstaller.py [--name=输出可执行文件名] [--onefile（只指定一个python文件）] [--console|--windowed（命令行还是窗口程序）] [--icon=指定程序icon（仅windows有用）] [--distpath=输出路径（默认为pyinstaller文件夹）]
4,生成.exe

2014-4-24
证书相关（RSA）
pem,der格式证书: pem为BASE64形式，der为ASN1的DER标准格式(二进制)。
key文件: 可由openssl产生的RSA公私钥对（还不是证书），最好用des或aes保护公私钥对，主要是私钥。
csr文件: 证书申请文件，可用openssl由key文件生成，填写subject等信息，生成可理解为未经CA签名的公钥证书，即证书请求文件。
公钥证书: 经过CA加签的公钥证书，含有CA填写的序列号及CA签名以及颁发者，开始时间截止时间等信息的公钥证书。
CSL列表: 废弃的证书列表，以subject和序列号标识。
自签名证书: 即rootCA，根证书，表现为subject（证书拥有者）与issure（证书颁发者）相同，其中CA签名可用自己证书内的公钥进行验签。实际上这种证书一般是加在所有浏览器的信任列表的。
证书链: SSL在得到证书时需要验证该证书的真伪，会根据其issure字段查看其颁发者，再根据其颁发者的证书字段看这个证书的颁发者，最终溯源到自签名的根证书（该根证书一定要在信任列表中），这样的一个链为证书链
检测证书的合法性时会构造证书链并一步一步往下检测证书链中证书过期时间，CA签名，是否在CSL当中等，遇到一张证书无法通过即停止通信，最终验证根证书，根证书一定要在信任列表中。
证书中包含的项目: version(X509证书版本一般为0x02，即3)，serial Number(序列号)，Signature Algorithm（签名算法如md5WithRSAEncryption），Issuer（颁发者如C=AU, ST=Some-State, O=Internet Widgits Pty Ltd, CN=fordesign/Email=fordeisgn@21cn.com），
Validity（有效期，其中包含Not Before(不早于如Nov 9 04:02:07 2000 GMT)，not after(不晚于如Nov 9 04:02:07 2001 GMT)），subject（实体名即证书拥有者如C=AU, ST=Some-State, O=Internet Widgits Pty Ltd, CN=fordesign/Email=fordeisgn@21cn.com），
Subject Public Key Info（证书拥有者，即该证书公钥信息）其中含有Public Key Algorithm（公钥算法如rsaEncryption），RSA Public Key（RSA公钥长度如(1024bit)），Modulus (1024 bit)RSA模长，下面即是RSA公钥，。。。（可看下证书示例）
Certificate: 
    Data: 
    Version: 3 (0x2) 
    Serial Number: 0 (0x0) 
    Signature Algorithm: md5WithRSAEncryption 
    Issuer: C=AU, ST=Some-State, O=Internet Widgits Pty Ltd, 
    CN=fordesign/Email=fordeisgn@21cn.com 
    Validity 
    Not Before: Nov 9 04:02:07 2000 GMT 
    Not After : Nov 9 04:02:07 2001 GMT 
    Subject: C=AU, ST=Some-State, O=Internet Widgits Pty Ltd, 
    CN=fordesign/Email=fordeisgn@21cn.com 
    Subject Public Key Info: 
    Public Key Algorithm: rsaEncryption 
    RSA Public Key: (1024 bit) 
    Modulus (1024 bit): 
    00:e7:62:1b:fb:78:33:d7:fa:c4:83:fb:2c:65:c1: 
    08:03:1f:3b:79:b9:66:bb:31:aa:77:d4:47:ac:be: 
    e5:20:ce:ed:1f:b2:b5:4c:79:c9:9b:ad:1d:0b:7f: 
    84:49:03:6b:79:1a:fd:05:ca:36:b3:90:b8:5c:c0: 
    26:93:c0:02:eb:78:d6:8b:e1:91:df:85:39:33:fc: 
    3d:59:e9:7f:58:34:bf:be:ef:bd:22:a5:be:26:c0: 
    16:9b:41:36:45:05:fe:f9:b2:05:42:04:c9:3b:28: 
    c1:0a:48:f4:c7:d6:a8:8c:f9:2c:c1:1e:f5:8b:dc: 
    19:59:7c:47:f7:91:cc:5d:75 
    Exponent: 65537 (0x10001) 
    X509v3 extensions: 
    X509v3 Subject Key Identifier: 
    69:41:87:55:BD:52:99:D0:F5:EC:11:7F:0A:01:53:58:4E:0B:7C:F7 
    X509v3 Authority Key Identifier: 
    keyid:69:41:87:55:BD:52:99:D0:F5:EC:11:7F:0A:01:53:58: 
    4E:0B:7C:F7 
    DirName:/C=AU/ST=Some-State/O=Internet Widgits Pty 
    Ltd/CN=fordesign/Email=fordeisgn@21cn.com 
    serial:00 
    X509v3 Basic Constraints: 
    CA:TRUE 
    Signature Algorithm: md5WithRSAEncryption 
    79:14:99:4a:8f:64:63:ab:fb:ad:fe:bc:ba:df:53:97:c6:92: 
    41:4d:de:fc:59:98:39:36:36:8e:c6:05:8d:0a:bc:49:d6:20: 
    02:9d:a2:5f:0f:03:12:1b:f2:af:23:90:7f:b1:6a:86:e8:3e: 
    0b:2c:fd:11:89:86:c3:21:3c:25:e2:9c:de:64:7a:14:82:32: 
    22:e1:35:be:39:90:f5:41:60:1a:77:2e:9f:d9:50:f4:81:a4: 
    67:b5:3e:12:e5:06:da:1f:d9:e3:93:2d:fe:a1:2f:a9:f3:25: 
    05:03:00:24:00:f1:5d:1f:d7:77:8b:c8:db:62:82:32:66:fd: 
    10:fa 

有些证书含有keyusage项为证书用途项（详情见下）
SSL client : Yes 
    SSL client CA : No 
    SSL server : Yes 
    SSL server CA : No 
    Netscape SSL server : Yes 
    Netscape SSL server CA : No 
    S/MIME signing : Yes 
     S/MIME signing CA : No 
    S/MIME encryption : Yes 
     S/MIME encryption CA : No 
     CRL signing : Yes 
    CRL signing CA : No 
    Any Purpose : Yes 
    Any Purpose CA : Yes 
    SSL Client 
    SSL Client CA 



openssl相关命令:
openssl -genrsa [-des|-3des|-idea] -out XXX [num]: 生成num位的RSA公私钥对，即生成XXX的key文件。
openssl req [-inform [pem|der]] -outform [pem|der] -keyform [pem|der] -new -key XXXkey -out XXXcsr :通过XXXkey文件生成XXXcsr文件
openssl ca -in XXXcsr -keyfile cakey -cert cacert -days num -out XXXpem :通过私钥为cakey公钥证书为cacert的CA为XXXcsr证书请求文件签名有效期为num天的XXXpem公钥证书文件。
openssl X509 -purpose -in XXXpem :查看该证书可用的用途，这个内容在CA签名时指定-extensions指定
openssl X509 -req -inform [pem|der] -outform [pem|der] -CAkey cakey -CA capem -CAcreateserial -in XXXcsr -out XXXpem -CAform [...] -CAkeyform [...] -extensions section -extfile filename1 -days num:
通过以cakey为私钥，capem为CA证书的CA为XXXcsr证书请求文件签发有效期为num日，可用于section及在filename1中定义了的作用的XXXpem公钥证书，其中CAcreateserial可在没有生成序列号文件时产生序列号文件并在XXXpem中填入序列号文件。

openssl X509 -req -in cacsr -signkey cakey -out capem -extensions v3_ca -extfile filename1 :为cacsr请求文件签发以cakey(即cacsr对应的私钥公钥对)签名的作用为CA及filename1中的作用的自签名证书capem。
cat XXXkey XXXpem > XXXkeypem :生成签过名的私钥证书。

2014-05-01
ssh相关知识
启动sshd,即service ssh start
关闭sshd,即service ssh stop
开启22端口，为服务器开通安全的信道，可作为ftp,telnet等的安全信道，由此又sftp,ssh的shell功能；此外还具有建立任何其他安全转发信道的功能。
一，建立安全信道过程:
协商ssh版本：ssh1用RSA，ssh2用DH协商密钥，若客户端与服务器端版本不统一则连接断开。该阶段还协商一个随机数r。
验证服务器身份：
	a，服务器将自己的公钥（hostkey）和该公钥对应的私钥（dhostkey）签名的R发给客户端。即发送hostkey+sign(dhostkey,r)
	b，客户端接收到hostkey，比对自己的knownhost文件中，所连接的sshd服务器的IP，域名（地址）是否与该hostkey匹配。若不匹配断开连接，不存在则提示用户是否添加该地址和该hostkey的对应关系入knownhost。
	c，比对hostkey是否是与服务器地址匹配后，验证服务器端签名checkSign(hostkey,sign(dhostkey,r),r)，若验签不成功，断开连接。
建立加密信道：
	a，客户端随机产生会话密钥skey，然后用服务器公钥hostkey加密传给服务器端，即发送e(hostkey,skey)
	b，服务器端用私钥dhostkey解密得到skey，即skey=d(dhostkey,e(hostkey,skey))，最终客户端和服务器端均用skey作为对称密钥来进行后续通讯。
验证客户端身份：
	a，服务器端会根据自己的sshd配置(/etc/ssh/sshd_config)，发送相应的challage给客户端验证，其过程均用skey加密。一般challege有公钥验证和密码验证两种（可两者都验证，这要看服务器配置），最终验证结束服务器会在challege结构中发送none表示验证通过。注意即使中间已有一环验证不通过了，服务器仍会继续把整个验证链走完然后给客户端一个结果，成功则信道建立。
		1)密码验证：服务器端发送challage_password请求，客户端传送用户名密码，若该用户名密码匹配sshd服务器上linux操作系统上该用户名的操作系统登录密码则通过验证。                                                                                        
		2)公钥验证：服务器端发送challege_e请求，客户端发送自己要登录的用户名，以及该登录用户所对应的私钥签名的r给服务器端，即发送username+sign(id_rsa,r)，该id_rsa私钥一般存在使用ssh客户端登录用户的用户根目录中的.ssh/id_rsa上。服务器端根据客户端欲登录的用户根目录下.ssh/authorized_keys文件里面所存公钥id_rsa.pub来验签，若不通过则设置拒绝状态。即checkSign(id_rsa.pub,sign(id_rsa,r),r)。

ssh建立安全信道所用的一些文件：
客户端文件：
	/etc/ssh/ssh_config :客户端ssh配置文件，一般默认就好。
	~/.ssh/knownhost :存储服务器地址与服务器公钥匹配的文件，客户端用于验证服务器发送的公钥hostkey是否是相应服务器所有的配置文件。
	~/.ssh/id_rsa :存储客户端用于公钥验证挑战时，给随机数签名的私钥。
服务器端文件：
	/etc/ssh/sshd_config :服务器端sshd配置文件，默认只用用户名密码验证挑战，可修改为同时验证公钥，或者是只验证公钥。
	~/.ssh/authorized_keys :存储服务器端验证客户端欲登录该用户时，进行公钥验证挑战时所用的公钥，客户端发送私钥签名时用其中的公钥进行验签。
	/etc/ssh/[ssh_host_dsa_key|ssh_host_dsa_key.pub|ssh_host_key|ssh_host_key.pub|ssh_host_rsa_key|ssh_host_rsa_key.pub] :存储hostkey文件路径，有RSA，DSA公私钥文件。
文件权限：~/.ssh权限必须为拥有者为~该用户，权限为700，~/.ssh/id_rsa权限必须为拥有者为使用ssh客户端登录的用户，权限为600，~/.ssh/authorized_keys权限必须为拥有者为~该用户，权限为600。

sshd配置：
PubkeyAuthentication [yes|no] :启用或关闭公钥验证
PasswordAuthentication [yes|no] :启用或关闭密码验证
AuthorizedKeysFile .ssh/XXX :设置服务器端验证客户端私钥签名的公钥存储文件
SubSystem sftp XXX/sftp_server :设置sftp子系统路径

sshd子系统有sftp,scp,stelnet

scp命令
scp -p port(一般为22，默认为22) local_file remote_username@remote_ip:remote_file  ：文件复制，从本地local_file发送到以remote_username为用户名的remote_ip作为地址的主机的remote_file路径上。sftp是以ssh程序建立连接隧道的。
scp remote_username@remote_ip:remote_file local_file  :远程文件拷贝到本地
scp -r remote_username@remote_ip:remote_fold local_fold  :拷贝路径

sftp命令
ssh sftp remote_username@remote_host
sftp>put local_file remote_file  :上传local_file到远程remote_file
sftp>get remote_file local_file  :下载

端口转发与ssh代理：
ssh -L localPort:rrmoteHost:rrmotePort remoteHost  :ssh客户端在本机127.0.0.1监听localPort，并建立与remoteHost的ssh连接（隧道）。所有发送到ssh客户端本机localPort的数据都会通过ssh隧道发送到remoteHost，remoteHost sshd服务器接收到数据把数据发送到rrmoteHost:rrmotePort地址上，返回的数据原路返回。
ssh -g -L localPort:rrmoteHost:rrmotePort remoteHost  :比于上面的命令，可以让其他机器连接本机的localPort端口进行隧道转发。

ssh -R localPort:rrmoteHost:rrmotePort remoteHost  :ssh客户端连接remoteHost sshd服务器，让其在sshd服务器上127.0.0.1监听localPort端口，所有发送到sshd服务器上localPort端口的数据将转发给ssh客户端，客户端转发给rrmoteHost:rrmotePort地址，返回的数据原路返回。
ssh -g -R localPort:rrmoteHost:rrmotePort remoteHost  :比于上面的命令，可以让其他机器连接sshd服务器的localPort端口进行隧道转发。

ssh -D localPort remoteHost  :ssh客户端在本机127.0.0.1监听localPort端口，并建立与remoteHost sshd服务器的连接。相当于实现了一个SOCKS代理，连接ssh客户端本机localPort端口发送的HTTP协议数据发送到remote sshd服务器端，服务器端根据HTTP数据包url发送到指定网站，返回的response原路返回。
ssh -g -D localPort remoteHost  :比于上面的命令，可以让其他机器连接本机的localPort端口进行隧道转发。

公钥登录配置：
1，生成公私钥对，公钥放于sshd服务器上
a)ssh-keygen生成RSA公私钥对 :执行ssh-keygen，它会交互式的让你输入生成的公私钥存储位置，私钥密码，不填密码为空。然后把私钥取回客户端，公钥使用命令 cat 公钥文件 >> ~/.ssh/authorized_keys 将其放入服务器端公钥认证文件中。
b)secureCRT生成公私钥对 :公钥放入sshd服务器，并使用ssh-keygen -i -f 公钥文件 >> ~/.ssh/authorized_keys 格式化公钥格式为UNIX格式，将其放入服务器端公钥认证文件中。
2，私钥存在.ssh/id_rsa上，secureCRT登录会指定私钥位置。

/proc/meminfo中
buffer+cached是文件系统高速缓存。tmpfs是基于高速缓存的文件系统，是共享内存底层实现方式，它所占用的内存也是shmem。
LRU表，一张L表记录最近未使用的内存页，R表记录最近使用过的内存页。当L表页被访问移动到R表，R表中的也一段时间未访问移到L表。

进程
fork exec模式
fork克隆出来一个进程，fork返回-1失败，+为父进程，返回值为子进程pid，0为子进程。其中子进程进程名等和父进程完全一致。
exec将自己的代码区等替换成指定代码区，会改变进程名等。
linux启动进入init进程.mig让用户输入用户名，mig进程fork exec到login进程，mig进程本身wait login进程，login进程验证密码后exec到/bin/bash进程，bash进程输出命令行让用户输入。
输入命令后，bashfork exec相应进程后wait。用&符号bashfork exec进程后输出命令行。bash执行exit命令，将结束自身进程，并给自己所有子进程输出hup信号，子进程均退出，父进程mig收到chld信号结束，init进程收到chld信号。
nohup命令使得bash退出时不发送hup信号给该进程
screen使mig和bash在退出后一直存在

java从子类强制类型转换到父类极耗性能。
